/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 diamond_engagement_ring.glb 
Author: assetfactory (https://sketchfab.com/assetfactory)
License: SKETCHFAB Standard (https://sketchfab.com/licenses)
Source: https://sketchfab.com/3d-models/diamond-engagement-ring-76c5820088d34eae934a23d043d1fec3
Title: Diamond Engagement Ring
*/

import { WebGLRenderTarget, Object3D } from "three"
import React, { useRef, useMemo, useLayoutEffect } from "react"
import { useLoader, useThree, useFrame } from "@react-three/fiber"
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader"
import lerp from "lerp"
import BackfaceMaterial from "./BackfaceMaterial"
import RefractionMaterial from "./RefractionMaterial"
import { useBlock } from "../blocks"
import state from "../Store"


const dummy = new Object3D()

export default function Diamonds1() {
  const { nodes } = useLoader(GLTFLoader, "../../public/diamond1.glb")
  console.log(nodes) // Debug the structure of nodes
  useLayoutEffect(() => {
    if (nodes.pCone1_lambert1_0) {
      nodes.pCone1_lambert1_0.geometry.center() // Update this line based on the correct structure
    } else {
      console.error("Node 'pCone1_lambert1_0' not found in the loaded GLTF model.")
    }
    return undefined // Explicitly return undefined
  }, [])

  if (!nodes.pCone1_lambert1_0) {
    return <></> // Return an empty fragment if the node is not found
  }

  const { size, gl, scene, camera, clock } = useThree()
  const { contentMaxWidth, sectionHeight, mobile } = useBlock()
  const model = useRef()
  const ratio = gl.getPixelRatio()

  const [envFbo, backfaceFbo, backfaceMaterial, refractionMaterial] = useMemo(() => {
    const envFbo = new WebGLRenderTarget(size.width * ratio, size.height * ratio)
    const backfaceFbo = new WebGLRenderTarget(size.width * ratio, size.height * ratio)
    const backfaceMaterial = new BackfaceMaterial()
    const refractionMaterial = new RefractionMaterial({
      envMap: envFbo.texture,
      backfaceMap: backfaceFbo.texture,
      resolution: [size.width * ratio, size.height * ratio]
    })
    return [envFbo, backfaceFbo, backfaceMaterial, refractionMaterial]
  }, [size, ratio])

  
  useFrame(() => {
    if (model.current) {
      state.diamonds1.forEach((data, i) => {
        const t = clock.getElapsedTime() / 2
        const { x, offset, scale, factor } = data
        const s = (contentMaxWidth / 35) * scale
        data.pos.set(mobile ? 0 : x, lerp(data.pos.y, -sectionHeight * offset * factor + (state.top.current / state.zoom) * factor, 0.1), 0)
        dummy.position.copy(data.pos)
        if (i === state.diamonds.length - 1) dummy.rotation.set(0, t, 0)
        else dummy.rotation.set(t, t, t)
        dummy.scale.set(s, s, s)
        dummy.updateMatrix()
        model.current.setMatrixAt(i, dummy.matrix)
        model.current.instanceMatrix.needsUpdate = true
      })

      gl.autoClear = false
      camera.layers.set(0)
      gl.setRenderTarget(envFbo)
      gl.clearColor()
      gl.render(scene, camera)
      gl.clearDepth()
      camera.layers.set(1)
      if (model.current) model.current.material = backfaceMaterial
      gl.setRenderTarget(backfaceFbo)
      gl.clearDepth()
      gl.render(scene, camera)
      camera.layers.set(0)
      gl.setRenderTarget(null)
      gl.render(scene, camera)
      gl.clearDepth()
      camera.layers.set(1)
      if (model.current) model.current.material = refractionMaterial
      gl.render(scene, camera)
    }
  }, 1)


  return (
    <instancedMesh ref={model} layers={1} args={[nodes.pCone1_lambert1_0.geometry, null, state.diamonds1.length]} position={[0, 0, 50]} />
  )
}
